# these database objects act as a cache for computationally intensive schedule operations
# and are autogenerated.  don't attempt to manipulate them manually.
class ScheduleBlock < ActiveRecord::Base
  belongs_to :schedule
  has_and_belongs_to_many :events
  has_many :scheduled_event_positions, :dependent => :destroy
  has_and_belongs_to_many :tracks, :order => :position
  
  before_save do |block|
    events = block.events
    if events.size > 0
      block.start ||= events[0].start
      block.end ||= events[0].end
      events[1, events.size - 1].each do |event|
        if event.start < block.start
          block.start = event.start
        end
        if event.end > block.end
          block.end = event.end
        end
      end
    end
    block.start = Time.mktime(block.start.year, block.start.month, block.start.day, block.start.hour, 0, 0, 0)
    
    if not block.interval
      block.interval = 30.minutes
      if block.events.size > 0
        shortest_event_length = block.events[0].length
        
        # calculate last event end and which tracks are used in this block
        block.events.each do |event|
          if shortest_event_length > event.length and event.length > 0
            shortest_event_length = event.length
          end
        end
    
        # get more granular if we need to
        while shortest_event_length < (block.interval * 4) and block.interval > 60 do
          block.interval /= 2
        end
        
        # get less granular if we need to
        while shortest_event_length > (block.interval * 8) do
          block.interval *= 2
        end
      end
    end
    
    # ensure that we end on a multiple of interval
    schedlen = ((block.end - block.start) / block.interval).ceil * block.interval
    block.end = block.start + schedlen
  end
  
  def obtain_tracks
    if tracks.size == 0
      events.each do |event|
        event.tracks.each do |track|
          if (not tracks.include?(track)) and (schedule.tracks.include?(track))
            tracks.push(track)
          end
        end
      end
    end
    return tracks.sort {|a, b| a.position <=> b.position}
  end
  
  def obtain_event_positions
    if scheduled_event_positions.size != events.size
      scheduled_event_positions.destroy_all

      usetracks = obtain_tracks
      schedlen = self.end - self.start

      grabbed_columns = {}
      pregrabs = {}
      usetracks.each do |track|
        grabbed_columns[track] = {}
      end

      numcols = usetracks.size
      colsize = ((100.0 - 10.0) / numcols)
      now = self.start
        
      while now < self.end
        nowevents = []
        while events.size > 0 and events[0].start < (now + interval)
          nowevents.push(events.shift)
        end
      
        colnum = 0
        usetracks.each do |track|
          logger.debug "Formatting track #{track.id} at #{now} with colnum #{colnum}"
        
          # check for expired column grabs
          grabbed_columns[track].reject! { |col, time| time <= now }
        
          trackevents = nowevents.select {|e| e.tracks.include? track}
          eventnum = 0
        
          # pre-grab columns for upcoming events
          trackevents.each do |event|
            events.each do |e|
              if not pregrabs.has_key? e.id
                if e.tracks.include?(track) and e.start > event.start and e.start < event.end
                  pgcolnum = eventnum + 1
                  while grabbed_columns[track].has_key?(pgcolnum)
                    pgcolnum += 1
                  end
                  logger.debug "Event #{e.id} pregrabbing subcolumn #{pgcolnum} until #{e.start}"
                  grabbed_columns[track][pgcolnum] = e.start
                  pregrabs[e.id] = true
                end
              end
            end
          end
        
          # calculate visual dimensions for each event
          eventsize = (colsize - 0.5) / (trackevents.size + grabbed_columns[track].size)          
          trackevents.each do |event|
            if scheduled_event_positions.find_by_event_id(event.id)
              # we already calculated this event
              next
            end
            
            while grabbed_columns[track].has_key?(eventnum)
              eventnum += 1
            end
            
            trackcount = event.tracks.select do |eventtrack|
              usetracks.include? eventtrack
            end.size
            
            scheduled_event_positions.create(:event => event,
              :left => (colsize * colnum) + (eventsize * eventnum) + 10.0,
              :width => trackcount > 1 ? trackcount * colsize : eventsize,
              :top => ((event.start - self.start) / schedlen) * 100.0,
              :height => ((event.end - event.start) / schedlen) * 100.0,
              :color => trackcount > 1 ? '#ffc' : track.color
              )
          
            grabbed_columns[track][eventnum] = event.end
            logger.debug "Event #{event.id} grabbing subcolumn #{eventnum} until #{event.end}"
            eventnum += 1
          end
        
          colnum += 1
        end
      
        now += self.interval
      end
    end
    
    return scheduled_event_positions
  end
end
